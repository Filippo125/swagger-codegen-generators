{{>partial_header}}
package {{apiPackage}}

import (
    "net/http"
    "encoding/json"
{{#imports}}
    {{{import}}}
{{/imports}}
    )

{{#operations}}
type {{classname}} interface {
    {{#operation}}
        {{#contents}}
        {{operationId}}({{#parameters}}{{>queryParams}}{{>pathParams}}{{>headerParams}}{{>bodyParams}}{{>formParams}}{{>cookieParams}}{{#hasMore}},{{/hasMore}}{{/parameters}}) (int, map[string]string,interface{})
        {{/contents}}
    {{/operation}}
}
{{/operations}}

{{#operations}}
{{#operation}}

func {{operationId}}Handler(p {{classname}})  http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var b []byte
        var err error
        {{#contents}}
        {{#parameters}}
        var {{paramName}} {{dataType}}
        {{/parameters}}
        {{>requestHeaderParams this}}
        {{>requestPathParams this}}
        {{>requestQueryParams this}}
        {{>requestBodyParams this}}
        {{/contents}}
        statusCode, headers, response := p.{{operationId}}({{#contents}}{{#parameters}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/parameters}}{{/contents}})
        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        for key, value := range headers {
            w.Header().Set(key, value)
        }
        if b, err = json.Marshal(response); err != nil {
            {{#useLogrus}}log.Errorf(err.Error()){{/useLogrus}}
            {{^useLogrus}}log.Printf(err.Error()){{/useLogrus}}
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        if _, err = w.Write(b); err != nil {
            {{#useLogrus}}log.Errorf(err.Error()){{/useLogrus}}
            {{^useLogrus}}log.Printf(err.Error()){{/useLogrus}}
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        w.WriteHeader(statusCode)
    }
}{{/operation}}{{/operations}}
